Given a graph $G = (V, E)$ with $|V| = n$ nodes, we aim to find a partition of the nodes that maximizes the cut, i.e., the number of edges between the two partitions. This can be formulated as finding (via variational optimization) parameters of a Cirq quantum circuit whose measurement outcomes encode candidate cuts; the best cut approximates the ground state of the Max-Cut Hamiltonian $H_{cut}$. The total number of qubits for this circuit is $n$. Each qubit represents one node in the graph, and all qubits must be measured using a single multi-bit measurement key (e.g., `m`). The classical measurement bits correspond one-to-one with the qubits. \n\nPlease provide the following components for the algorithm design with $n = \\{qubit number\\}$ and a $graph\\ type = \\{Cycle / 3-Regular\\}$ graph $G = \\{graph file\\}$:\n\n1. **Cirq Circuit Implementation**\n   - You must implement a function with the exact signature:\n     ```python\n     import cirq, sympy as sp\n\n     def algorithm(graph):\n         # graph is a networkx.Graph where nodes are 0..n-1\n         # Build a parameterized Cirq circuit c on n qubits\n         # Parameters must be named theta_0, theta_1, ...\n         # Include a single multi-qubit measurement: cirq.measure(*q, key='m')\n         return c\n     ```\n   - **Parameter Naming Rule:** Each parameter must be defined as a unique sympy.Symbol named exactly `theta_0`, `theta_1`, ... (no bracket or index notation like `theta[0]`).\n   - All parameters must be used in parameterized gates (e.g., `cirq.rx(2*theta_k)`, `cirq.rz(2*theta_k)`, etc.).\n   - All qubits must be measured together with `cirq.measure(*q, key='m')`.\n\n2. **Post-Processing Function** `run_and_analyze(circuit, graph)`\n   - Signature:\n     ```python\n     def run_and_analyze(circuit: cirq.Circuit, graph) -> list[str]:\n         ...\n     ```\n   - **Allowed Libraries:**\n     - `scipy.optimize.minimize` for classical optimization\n     - `cirq` (for simulation and parameter binding)\n     - `compute_expectation(counts, graph)` (provided externally; computes expectation value)\n   - You must NOT redefine or rebuild a new circuit inside this function; only use the provided `circuit`.\n   - Extract all parameters from the circuit with `cirq.parameter_symbols(circuit)`, sort them, and initialize:\n     ```python\n     initial_params = [initial_value] * len(params)\n     ```\n     (e.g., `initial_value = 1.0`).\n   - Simulate the circuit with `cirq.Simulator()` using a parameter resolver:\n     ```python\n     result = sim.run(bound_circuit, repetitions=SHOTS)\n     counts = {...}  # aggregate bitstrings from result.measurements['m']\n     ```\n   - Define the optimization objective to minimize the negative of the provided expectation:\n     ```python\n     def objective(theta):\n         # bind theta to circuit params\n         # counts = simulate(...)\n         # return -compute_expectation(counts, graph)\n     ```\n   - After optimization, bind the optimal parameters, resample the circuit, sort bitstrings by count frequency, and return the two most frequent bitstrings:\n     ```python\n     top_two = [state for state, cnt in sorted_counts[:2]]\n     return top_two\n     ```\n\n**Notes:**\n- Bitstrings must be extracted from `result.measurements['m']` as concatenations of measurement outcomes per shot (e.g., `'0101'`).\n- The order of bits must be consistent with qubit indexing.\n- The graph $G$ is provided as a `networkx.Graph` with nodes 0..n-1.\n- The final output must consist of **two fenced code blocks**:\n  1. ```cirq``` — containing the `algorithm(graph)` implementation.\n  2. ```python``` — containing the `run_and_analyze(circuit, graph)` implementation.\n- Do not include example usage.\n- All parameter names must strictly follow `theta_0`, `theta_1`, ... naming convention.