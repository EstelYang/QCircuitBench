Given a Hamiltonian $H$ acting on $n$ qubits (indexed $0$ to $n-1$), we aim to find the ground state $|\\psi_{\\text{ground}}\\rangle$ that minimizes the expectation value $\\langle \\psi | H | \\psi \\rangle$. The Hamiltonian is a sum of Pauli terms with real coefficients over $X$, $Y$, and $Z$ on specified qubit indices. **No ancilla qubits are required.**\n\nPlease provide the following components for the algorithm design with $n = \\{qubit number\\}$ to find the ground state energy of the Hamiltonian $H = \\{hamiltonian structure\\}$:\n\n1. **Cirq circuit implementation (parameterized)**\n   - Implement a Python function with the exact signature:\n     ```python\n     import cirq, sympy as sp\n\n     def algorithm():\n         # Build and return a parameterized Cirq circuit `c` on n qubits (LineQubit.range(n)).\n         # Use ONLY standard Cirq gates (e.g., cirq.rx, cirq.ry, cirq.rz, CNOT, etc.).\n         # Every free parameter MUST be a `sympy.Symbol` named exactly: theta_0, theta_1, ..., theta_{K-1}.\n         # (Do not use bracketed names like theta[0].)\n         return c\n     ```\n   - **Parameter naming rule:** strictly `theta_0`, `theta_1`, ... (no `theta[0]` form). Each declared parameter must actually appear in at least one parameterized gate (e.g., `cirq.rx(2*theta_k)`).\n   - Qubits must be created as `q = cirq.LineQubit.range(n)` and used in that index order (0..n-1).\n   - Do **not** add measurements (energy evaluation uses expectation values; measurements are not required).\n\n2. **Post-processing** `run_and_analyze(circuit, hamiltonian, expected_energy, optiter=200, tolerance=1e-3)`\n   - Implement the function with this exact signature:\n     ```python\n     def run_and_analyze(circuit: cirq.Circuit, hamiltonian, expected_energy: float, optiter: int = 200, tolerance: float = 1e-3):\n         # Optimize circuit parameters to minimize <H> and return (is_within_tolerance, error)\n         ...\n     ```\n   - **Allowed libraries inside this function:**\n     - `scipy.optimize.minimize` (for classical optimization)\n     - `cirq` (for simulation and parameter binding)\n   - **Inputs:**\n     - `circuit`: the parameterized Cirq circuit returned by `algorithm()`; you **must not** redefine or replace it.\n     - `hamiltonian`: either a `cirq.PauliSum` or a list of `(coef: float, pauli: cirq.PauliString)` terms; you **must not** rebuild it inside the function.\n     - `expected_energy`: the target ground-state energy (float) used to compute the final error.\n   - **Optimization objective:**\n     - Let `params = sorted(list(cirq.parameter_symbols(circuit)), key=str)` and `K = len(params)`.\n     - Initialize parameters as `initial_params = [1.0] * K`.\n     - Define\n       ```python\n       objective(theta) = <H>(theta)\n       ```\n       where `<H>(theta)` is computed by binding `theta` to `circuit` (in the **same order** as `params`) and evaluating the expectation value of each Pauli term with `cirq.Simulator().simulate_expectation_values(...)`, then summing with the corresponding coefficients.\n   - **Return values:**\n     - After optimization (e.g., COBYLA via `minimize` with `options={\"maxiter\": optiter}`), compute `best_energy`, then\n       ```python\n       error = abs(best_energy - expected_energy)\n       is_within_tolerance = (error <= tolerance)\n       return is_within_tolerance, error\n       ```\n   - **Restrictions:** Do **not** define custom gates; do **not** create new circuits or new Hamiltonians inside `run_and_analyze`; only use the provided `circuit` and `hamiltonian`.\n\n**Formatting requirements**\n- Your final answer must contain exactly **two fenced code blocks** in order:\n  1) ```cirq``` — the `algorithm()` implementation that builds and returns the parameterized Cirq circuit using parameters named `theta_0, theta_1, ...`.\n  2) ```python``` — the `run_and_analyze(circuit, hamiltonian, expected_energy, optiter=200, tolerance=1e-3)` implementation that uses **only** `scipy.optimize.minimize` and `cirq` to minimize the variational energy and returns `(is_within_tolerance, error)`.\n- Do **not** include example usage.\n- Do **not** use bracketed parameter names; strictly use `theta_0, theta_1, ...`.\n